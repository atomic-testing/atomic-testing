---
id: tutorial
title: 'Step-by-Step Tutorial'
sidebar_position: 5
---

This tutorial walks you through the `example-mui-signup-form` found in the `examples` folder. It demonstrates how to run the example application and introduces the basic **Atomic Testing** APIs for writing tests.

## 1. Install dependencies

From the repository root run:

```bash
pnpm install
```

The example project has its own dependencies so install them as well:

```bash
cd examples/example-mui-signup-form
pnpm install
```

## 2. Start the example application

Run the app locally to see the signup form in action:

```bash
pnpm dev
```

Open [http://localhost:5371](http://localhost:5371) in your browser to interact with the multi‑step form.

## 3. Run the component tests

Unit tests for each form step live under their respective `__tests__` directories. Execute them with:

```bash
pnpm test:dom
```

## 4. Run the end‑to‑end test

The example also includes an end‑to‑end scenario located in `e2e/success.spec.ts`. Launch it in Chrome with:

```bash
pnpm test:e2e:chrome
```

Add the `--ui` flag to open Playwright in UI mode if you want to watch the interactions.

## 5. Explore Storybook (optional)

Some components contain Storybook stories with interaction tests. To view them, run:

```bash
pnpm storybook
```

## 6. Write your first Atomic test

The signup form example includes unit tests written with **Atomic Testing**. The steps below outline the main pieces required to create a test.

### Declare `data-testid`

Assign the `data-testid` attribute on components that you need to interact with. This example shows the markup for the credential form:

```tsx title="CredentialForm.tsx"
<form data-testid={DataTestId.form}>
  <TextField data-testid={DataTestId.emailInput} label='Email' />
  <TextField data-testid={DataTestId.passwordInput} label='Password' />
  <WizardButton data-testid={DataTestId.navigation} onNextStep={onNextStep} />
</form>
```

### Define a ScenePart

Create a ScenePart describing how to locate each component and which driver to use:

```ts title="credentialScenePart.ts"
const parts = {
  form: {
    locator: byDataTestId(DataTestId.form),
    driver: CredentialFormDriver,
  },
} satisfies ScenePart;
```

### Instantiate the Test Engine and write a test

```ts title="CredentialForm.test.tsx"
let testEngine: TestEngine<typeof parts>;
let onNext: jest.Mock;

beforeEach(() => {
  onNext = jest.fn();
  testEngine = createTestEngineForComponent(
    <CredentialForm data-testid={DataTestId.form} onNextStep={onNext} />,
    parts
  );
});

afterEach(async () => {
  await testEngine.cleanUp();
});

test('submits valid data', async () => {
  await testEngine.parts.form.setValue({
    email: 'john@example.com',
    password: 'secret123',
    confirmPassword: 'secret123',
    birthday: '1990-01-01',
  });
  await testEngine.parts.form.next();
  expect(onNext).toHaveBeenCalled();
});
```

The test engine renders the component, exposes the parts defined in the `ScenePart`, and provides helper methods from the driver to interact with the component. Always call `cleanUp()` after each test to unmount the component and release resources.

## 7. Build a login form driver

Drivers can also model entire forms. Below is an example `LoginFormDriver` that wraps the username, password and submit parts. The `login()` method accepts an object with the credentials and performs all required interactions.

```ts title="LoginFormDriver.ts"
import { ButtonDriver, TextFieldDriver } from '@atomic-testing/component-driver-mui-v5';
import { ComponentDriver, Locator, Interactor, byDataTestId, ScenePart } from '@atomic-testing/core';

export const loginFormParts = {
  username: { locator: byDataTestId('username'), driver: TextFieldDriver },
  password: { locator: byDataTestId('password'), driver: TextFieldDriver },
  submit: { locator: byDataTestId('submit'), driver: ButtonDriver },
} satisfies ScenePart;

export class LoginFormDriver extends ComponentDriver<typeof loginFormParts> {
  constructor(locator: Locator, interactor: Interactor) {
    super(locator, interactor, { parts: loginFormParts });
  }

  async login(credentials: { username: string; password: string }): Promise<void> {
    await this.parts.username.setValue(credentials.username);
    await this.parts.password.setValue(credentials.password);
    await this.parts.submit.click();
  }

  get driverName(): string {
    return 'LoginFormDriver';
  }
}
```

Using this driver, a test becomes highly declarative:

```ts title="LoginForm.test.tsx"
await testEngine.parts.login.login({
  username: 'john@example.com',
  password: 'secret',
});
expect(await testEngine.parts.error.getText()).toBe('');
```

If the login implementation changes you only need to update the driver, not every test.

## Next steps

Browse the example source code to see how scene parts, drivers and the test engine are set up. Then refer back to the [Setup](./setup.mdx) and [Core Concepts](./core-concepts.mdx) pages for more details on creating your own tests.
