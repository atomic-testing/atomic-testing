"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["9354"],{812(e,t,n){n.r(t),n.d(t,{metadata:()=>o,default:()=>d,frontMatter:()=>r,contentTitle:()=>c,toc:()=>l,assets:()=>a});var o=JSON.parse('{"id":"cheat-sheets","title":"Cheat Sheets","description":"Most of the time, unit tests fail because the component","source":"@site/docs/cheat-sheets.mdx","sourceDirName":".","slug":"/cheat-sheets","permalink":"/docs/cheat-sheets","draft":false,"unlisted":false,"editUrl":"https://github.com/atomic-testing/atomic-testing/tree/main/docs/docs/docs/cheat-sheets.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"cheat-sheets","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Best Practices","permalink":"/docs/best-practices"},"next":{"title":"API overview","permalink":"/docs/api-overview"}}'),s=n(77900),i=n(36493);let r={id:"cheat-sheets",sidebar_position:6},c="Cheat Sheets",a={},l=[{value:"1. Inspect component HTML",id:"1-inspect-component-html",level:3},{value:"2. Get component runtime CSS selector",id:"2-get-component-runtime-css-selector",level:3},{value:"3. Wait for the component to be visible",id:"3-wait-for-the-component-to-be-visible",level:3},{value:"4. Log DOM interactions",id:"4-log-dom-interactions",level:3},{value:"5. Clean up after each test",id:"5-clean-up-after-each-test",level:3}];function h(e){let t={code:"code",h1:"h1",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"cheat-sheets",children:"Cheat Sheets"})}),"\n",(0,s.jsx)(t.p,{children:"Most of the time, unit tests fail because the component\nis not found or is rendered asynchronously. Incorrect\nlocators or hidden elements are common culprits. The\ntips below help diagnose these issues."}),"\n",(0,s.jsx)(t.h3,{id:"1-inspect-component-html",children:"1. Inspect component HTML"}),"\n",(0,s.jsxs)(t.p,{children:["You may use ",(0,s.jsx)(t.code,{children:"innerHTML()"})," to inspect the HTML of a component. This can be useful for debugging or troubleshooting."]}),"\n",(0,s.jsx)(t.p,{children:"Getting the HTML of a component can be useful to get a snapshot of the component's HTML structure and verify if it matches your expectations.\nHowever it can be overwhelming to read the HTML, so use it wisely."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const html = await testEngine.parts.myComponent.innerHTML();\nconsole.log(html);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"2-get-component-runtime-css-selector",children:"2. Get component runtime CSS selector"}),"\n",(0,s.jsxs)(t.p,{children:["You may use ",(0,s.jsx)(t.code,{children:"runtimeCssSelector()"})," to get the runtime CSS selector of a component, and use it to query the DOM for the component in the browser,\nthis is especially useful when you have a Storybook story that renders the component, which allows you to inspect the component visually in the browser."]}),"\n",(0,s.jsxs)(t.p,{children:["Use of ",(0,s.jsx)(t.code,{children:"runtimeCssSelector()"})," is helpful to troubleshoot if the locator setting is correct."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"const selector = await testEngine.parts.myComponent.runtimeCssSelector();\nconsole.log(selector);\n\n// You can use the selector to query the DOM for the component in the browser.\ndocument.querySelector(selector);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"3-wait-for-the-component-to-be-visible",children:"3. Wait for the component to be visible"}),"\n",(0,s.jsxs)(t.p,{children:["If your assertions run before the component finishes rendering,\nuse ",(0,s.jsx)(t.code,{children:"waitUntilVisible()"})," to pause until the part is attached\nand displayed."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"await testEngine.parts.myComponent.waitUntilVisible();\n"})}),"\n",(0,s.jsx)(t.h3,{id:"4-log-dom-interactions",children:"4. Log DOM interactions"}),"\n",(0,s.jsx)(t.p,{children:"When troubleshooting complex behaviour, a custom interactor can\nprint every action for inspection."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="LoggingInteractor.ts"',children:"import { ClickOption, PartLocator } from '@atomic-testing/core';\nimport { DOMInteractor } from '@atomic-testing/dom-core';\n\nexport class LoggingInteractor extends DOMInteractor {\n  async click(locator: PartLocator, option?: Partial<ClickOption>): Promise<void> {\n    console.log('clicking', await this.innerHTML(locator));\n    await super.click(locator, option);\n  }\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Pass this interactor when creating the test engine so clicks are logged."}),"\n",(0,s.jsx)(t.h3,{id:"5-clean-up-after-each-test",children:"5. Clean up after each test"}),"\n",(0,s.jsx)(t.p,{children:"Always unmount the component to avoid cross\u2011test contamination."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"afterEach(async () => {\n  await testEngine.cleanUp();\n});\n"})})]})}function d(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},36493(e,t,n){n.d(t,{R:()=>r,x:()=>c});var o=n(82128);let s={},i=o.createContext(s);function r(e){let t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);