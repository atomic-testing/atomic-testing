"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([["6075"],{21576(e,t,n){n.r(t),n.d(t,{metadata:()=>r,default:()=>h,frontMatter:()=>c,contentTitle:()=>o,toc:()=>d,assets:()=>a});var r=JSON.parse('{"id":"advanced-concepts/architecture","title":"Architecture","description":"The diagram below shows how the key pieces of Atomic Testing fit together.","source":"@site/docs/advanced-concepts/architecture.mdx","sourceDirName":"advanced-concepts","slug":"/advanced-concepts/architecture","permalink":"/docs/advanced-concepts/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/atomic-testing/atomic-testing/tree/main/docs/docs/docs/advanced-concepts/architecture.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"architecture","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Interactor","permalink":"/docs/advanced-concepts/interactor"},"next":{"title":"Atomic Testing vs React Testing Library","permalink":"/docs/advanced-concepts/atomic-testing-vs-rtl"}}'),s=n(77900),i=n(36493);let c={id:"architecture",sidebar_position:3},o="Architecture",a={},d=[{value:"Test Engine",id:"test-engine",level:2},{value:"Component Drivers",id:"component-drivers",level:2},{value:"ScenePart",id:"scenepart",level:2},{value:"Interactor",id:"interactor",level:2},{value:"Putting it all together",id:"putting-it-all-together",level:2}];function l(e){let t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",mermaid:"mermaid",p:"p",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"architecture",children:"Architecture"})}),"\n",(0,s.jsx)(t.p,{children:"The diagram below shows how the key pieces of Atomic Testing fit together."}),"\n",(0,s.jsx)(t.mermaid,{value:"flowchart TD\n    TestCode[Test Code] --\x3e TestEngine\n    TestEngine --\x3e|creates| ComponentDriver\n    ComponentDriver --\x3e|delegates actions to| Interactor\n    ComponentDriver --\x3e|locates child parts| ScenePart\n    Interactor --\x3e DOMInteractor\n    Interactor --\x3e PlaywrightInteractor\n    DOMInteractor --\x3e|run tests in| UnitTests[Unit Tests]\n    PlaywrightInteractor --\x3e|run tests in| e2etests[End-to-End Tests]"}),"\n",(0,s.jsx)(t.p,{children:"Atomic Testing follows a layered design so that your test code stays the same no\nmatter which rendering library or test runner you use. The main pieces from the\ndiagram are described below."}),"\n",(0,s.jsx)(t.h2,{id:"test-engine",children:"Test Engine"}),"\n",(0,s.jsxs)(t.p,{children:["The test engine renders a scene and wires up every component defined in a\n",(0,s.jsx)(t.code,{children:"ScenePart"}),". It exposes these parts through a typed API so tests can interact\nwith them. Engines exist for React, Vue and other frameworks\u2014see the\n",(0,s.jsx)(t.a,{href:"/docs/setup",children:"Setup"})," and ",(0,s.jsx)(t.a,{href:"/docs/concepts#test-engine",children:"Core Concepts"}),"\nsections for examples."]}),"\n",(0,s.jsx)(t.h2,{id:"component-drivers",children:"Component Drivers"}),"\n",(0,s.jsxs)(t.p,{children:["Drivers encapsulate how to operate a component. Rather than querying the DOM in\nevery test, you call methods such as ",(0,s.jsx)(t.code,{children:"click()"})," or ",(0,s.jsx)(t.code,{children:"setValue()"})," on the driver.\nDrivers may also contain child parts, allowing complex widgets to be composed\nfrom simpler ones. The engine instantiates drivers based on the ",(0,s.jsx)(t.code,{children:"ScenePart"}),"\ndefinition. Learn how to build your own drivers in\n",(0,s.jsx)(t.a,{href:"/docs/advanced-concepts/build-component-driver",children:"Build Component Driver"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"scenepart",children:"ScenePart"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"ScenePart"})," acts as a blueprint describing the parts a scene exposes\u2014their\nlocators and which driver class to use. Scene parts can be nested so larger\nscenes reuse smaller ones. Refer to the\n",(0,s.jsx)(t.a,{href:"/docs/concepts#scenepart",children:"Core Concepts"})," page for an in-depth look."]}),"\n",(0,s.jsx)(t.h2,{id:"interactor",children:"Interactor"}),"\n",(0,s.jsxs)(t.p,{children:["Interactors perform the low level actions requested by drivers. ",(0,s.jsx)(t.code,{children:"DOMInteractor"}),"\nworks with ",(0,s.jsx)(t.code,{children:"@testing-library"})," utilities for unit tests while\n",(0,s.jsx)(t.code,{children:"PlaywrightInteractor"})," targets a real browser for end-to-end scenarios. Because\ndrivers talk only to the interactor interface, the same driver code can operate\nin both environments. See the ",(0,s.jsx)(t.a,{href:"/docs/advanced-concepts/interactor",children:"Interactor"})," guide for details\non creating custom interactors."]}),"\n",(0,s.jsx)(t.h2,{id:"putting-it-all-together",children:"Putting it all together"}),"\n",(0,s.jsxs)(t.p,{children:["When a test calls ",(0,s.jsx)(t.code,{children:"engine.parts.button.click()"}),", the call flows through the\ndriver into the interactor, which then manipulates the actual UI element. This\nindirection keeps tests declarative and portable across environments while still\nletting you reuse driver code and scene definitions."]})]})}function h(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},36493(e,t,n){n.d(t,{R:()=>c,x:()=>o});var r=n(82128);let s={},i=r.createContext(s);function c(e){let t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);